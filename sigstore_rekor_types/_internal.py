# generated by datamodel-codegen:
#   timestamp: 2023-10-04T17:15:23+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import AnyUrl, BaseModel, EmailStr, Field, RootModel, StrictInt, StrictStr


class ProposedEntry(BaseModel):
    kind: StrictStr


class Format(Enum):
    PGP = "pgp"
    MINISIGN = "minisign"
    X509 = "x509"
    SSH = "ssh"


class PublicKey(BaseModel):
    content: str = Field(
        ...,
        description="Specifies the content of the public key inline within the document",
    )


class Signature(BaseModel):
    format: Format = Field(..., description="Specifies the format of the signature")
    content: str = Field(
        ...,
        description="Specifies the content of the signature inline within the document",
    )
    public_key: PublicKey = Field(
        ...,
        alias="publicKey",
        description="The public key that can verify the signature",
    )


class RekordV001Schema(BaseModel):
    signature: Signature = Field(
        ...,
        description="Information about the detached signature associated with the entry",
    )


class PublicKey1(BaseModel):
    content: Optional[str] = Field(
        None,
        description=(
            "Specifies the content of the public key or code signing certificate inline within the"
            " document"
        ),
    )


class Signature1(BaseModel):
    content: Optional[str] = Field(
        None,
        description="Specifies the content of the signature inline within the document",
    )
    public_key: Optional[PublicKey1] = Field(
        None,
        alias="publicKey",
        description=(
            "The public key that can verify the signature; this can also be an X509 code signing"
            " certificate that contains the raw public key information"
        ),
    )


class Algorithm(Enum):
    SHA256 = "sha256"


class Hash(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(..., description="The hash value for the content")


class Data(BaseModel):
    hash: Optional[Hash] = Field(
        None,
        description="Specifies the hash algorithm and value for the content",
    )


class HashedrekordV001Schema(BaseModel):
    signature: Signature1 = Field(
        ...,
        description="Information about the detached signature associated with the entry",
    )
    data: Data = Field(..., description="Information about the content associated with the entry")


class PublicKey2(BaseModel):
    content: str = Field(
        ...,
        description="Specifies the content of the public key inline within the document",
    )


class RpmV001Schema(BaseModel):
    public_key: PublicKey2 = Field(
        ...,
        alias="publicKey",
        description="The PGP public key that can verify the RPM signature",
    )


class Metadata(BaseModel):
    content: Dict[str, Any] = Field(
        ...,
        description="Specifies the metadata inline within the document",
    )


class Root(BaseModel):
    content: Dict[str, Any] = Field(
        ...,
        description="Specifies the metadata inline within the document",
    )


class TufV001Schema(BaseModel):
    spec_version: Optional[StrictStr] = Field(None, description="TUF specification version")
    metadata: Metadata = Field(..., description="TUF metadata")
    root: Root = Field(
        ...,
        description="root metadata containing about the public keys used to sign the manifest",
    )


class AlpineV001Schema(BaseModel):
    public_key: PublicKey2 = Field(
        ...,
        alias="publicKey",
        description="The public key that can verify the package signature",
    )


class Hash1(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(..., description="The hash value for the chart")


class Chart(BaseModel):
    hash: Optional[Hash1] = Field(
        None,
        description="Specifies the hash algorithm and value for the chart",
    )


class HelmV001Schema(BaseModel):
    public_key: PublicKey2 = Field(
        ...,
        alias="publicKey",
        description="The public key that can verify the package signature",
    )
    chart: Chart = Field(
        ...,
        description="Information about the Helm chart associated with the entry",
    )


class Hash2(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(..., description="The hash value for the archive")


class PayloadHash(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(..., description="The hash value for the envelope's payload")


class Content(BaseModel):
    envelope: Optional[StrictStr] = Field(None, description="envelope")
    hash: Optional[Hash2] = Field(
        None,
        description=(
            "Specifies the hash algorithm and value encompassing the entire signed envelope; this"
            " is computed by the rekor server, client-provided values are ignored"
        ),
    )
    payload_hash: Optional[PayloadHash] = Field(
        None,
        alias="payloadHash",
        description=(
            "Specifies the hash algorithm and value covering the payload within the DSSE envelope;"
            " this is computed by the rekor server, client-provided values are ignored"
        ),
    )


class IntotoV001Schema(BaseModel):
    content: Content
    public_key: str = Field(
        ...,
        alias="publicKey",
        description="The public key that can verify the signature",
    )


class Signature2(BaseModel):
    keyid: Optional[StrictStr] = Field(
        None,
        description="optional id of the key used to create the signature",
    )
    sig: str = Field(..., description="signature of the payload")
    public_key: str = Field(
        ...,
        alias="publicKey",
        description="public key that corresponds to this signature",
    )


class Envelope(BaseModel):
    payload: Optional[str] = Field(None, description="payload of the envelope")
    payload_type: StrictStr = Field(
        ...,
        alias="payloadType",
        description="type describing the payload",
    )
    signatures: List[Signature2] = Field(
        ...,
        description="collection of all signatures of the envelope's payload",
        min_length=1,
    )


class Hash3(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(..., description="The hash value for the archive")


class PayloadHash1(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(..., description="The hash value of the payload")


class Content1(BaseModel):
    envelope: Envelope = Field(..., description="dsse envelope")
    hash: Optional[Hash3] = Field(
        None,
        description=(
            "Specifies the hash algorithm and value encompassing the entire signed envelope"
        ),
    )
    payload_hash: Optional[PayloadHash1] = Field(
        None,
        alias="payloadHash",
        description=(
            "Specifies the hash algorithm and value covering the payload within the DSSE envelope"
        ),
    )


class IntotoV002Schema(BaseModel):
    content: Content1


class PayloadHash2(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(..., description="The hash value for the content")


class EnvelopeHash(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(..., description="The hash value for the envelope")


class Data1(BaseModel):
    payload_hash: Optional[PayloadHash2] = Field(
        None,
        alias="payloadHash",
        description="Specifies the hash algorithm and value for the content",
    )
    envelope_hash: Optional[EnvelopeHash] = Field(
        None,
        alias="envelopeHash",
        description="Specifies the hash algorithm and value for the COSE envelope",
    )
    aad: Optional[str] = Field(
        None,
        description="Specifies the additional authenticated data required to verify the signature",
    )


class CoseV001Schema(BaseModel):
    message: Optional[str] = Field(None, description="The COSE Sign1 Message")
    public_key: str = Field(
        ...,
        alias="publicKey",
        description="The public key that can verify the signature",
    )
    data: Data1 = Field(..., description="Information about the content associated with the entry")


class PublicKey5(BaseModel):
    content: str = Field(
        ...,
        description=(
            "Specifies the content of the X509 certificate containing the public key used to verify"
            " the signature"
        ),
    )


class Signature3(BaseModel):
    content: str = Field(
        ...,
        description="Specifies the PKCS7 signature embedded within the JAR file ",
    )
    public_key: PublicKey5 = Field(
        ...,
        alias="publicKey",
        description=(
            "The X509 certificate containing the public key JAR which verifies the signature of"
            " the JAR"
        ),
    )


class JarV001Schema(BaseModel):
    signature: Optional[Signature3] = Field(
        None,
        description="Information about the included signature in the JAR file",
    )


class Tsr(BaseModel):
    content: str = Field(
        ...,
        description="Specifies the tsr file content inline within the document",
    )


class Rfc3161V001Schema(BaseModel):
    tsr: Tsr = Field(..., description="Information about the tsr file associated with the entry")


class ProposedContent(BaseModel):
    envelope: StrictStr = Field(
        ...,
        description="DSSE envelope specified as a stringified JSON object",
    )
    verifiers: List[str] = Field(
        ...,
        description=(
            "collection of all verification material (e.g. public keys or certificates) used to"
            " verify signatures over envelope's payload, specified as base64-encoded strings"
        ),
        min_length=1,
    )


class Signature4(BaseModel):
    signature: StrictStr = Field(..., description="base64 encoded signature of the payload")
    verifier: str = Field(
        ...,
        description=(
            "verification material that was used to verify the corresponding signature, specified"
            " as a base64 encoded string"
        ),
    )


class EnvelopeHash1(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(
        ...,
        description="The value of the computed digest over the entire envelope",
    )


class PayloadHash3(BaseModel):
    algorithm: Algorithm = Field(
        ...,
        description="The hashing function used to compute the hash value",
    )
    value: StrictStr = Field(
        ...,
        description="The value of the computed digest over the payload within the envelope",
    )


class DsseV001Schema(BaseModel):
    proposed_content: Optional[ProposedContent] = Field(None, alias="proposedContent")
    signatures: Optional[List[Signature4]] = Field(
        None,
        description=(
            "extracted collection of all signatures of the envelope's payload; elements will be"
            " sorted by lexicographical order of the base64 encoded signature strings"
        ),
        min_length=1,
    )
    envelope_hash: Optional[EnvelopeHash1] = Field(
        None,
        alias="envelopeHash",
        description=(
            "Specifies the hash algorithm and value encompassing the entire envelope sent to Rekor"
        ),
    )
    payload_hash: Optional[PayloadHash3] = Field(
        None,
        alias="payloadHash",
        description=(
            "Specifies the hash algorithm and value covering the payload within the DSSE envelope"
        ),
    )


class Attestation(BaseModel):
    data: Optional[Dict[str, Any]] = None


class Format1(Enum):
    PGP = "pgp"
    X509 = "x509"
    MINISIGN = "minisign"
    SSH = "ssh"
    TUF = "tuf"


class PublicKey6(BaseModel):
    format: Format1
    content: Optional[str] = Field(
        None,
        pattern="^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
    )
    url: Optional[AnyUrl] = None


class Operator(Enum):
    AND_ = "and"
    OR_ = "or"


class SearchIndex(BaseModel):
    email: Optional[EmailStr] = None
    public_key: Optional[PublicKey6] = Field(None, alias="publicKey")
    hash: Optional[StrictStr] = None
    operator: Optional[Operator] = None


class EntryUuiD(RootModel[StrictStr]):
    root: StrictStr


class LogIndex(RootModel[StrictInt]):
    root: StrictInt


class SearchLogQuery(BaseModel):
    entry_uui_ds: Optional[List[EntryUuiD]] = Field(
        None,
        alias="entryUUIDs",
        max_length=10,
        min_length=1,
    )
    log_indexes: Optional[List[LogIndex]] = Field(
        None,
        alias="logIndexes",
        max_length=10,
        min_length=1,
    )
    entries: Optional[List[ProposedEntry]] = Field(None, max_length=10, min_length=1)


class InactiveShardLogInfo(BaseModel):
    root_hash: StrictStr = Field(
        ...,
        alias="rootHash",
        description="The current hash value stored at the root of the merkle tree",
    )
    tree_size: StrictInt = Field(
        ...,
        alias="treeSize",
        description="The current number of nodes in the merkle tree",
    )
    signed_tree_head: StrictStr = Field(
        ...,
        alias="signedTreeHead",
        description="The current signed tree head",
    )
    tree_id: StrictStr = Field(..., alias="treeID", description="The current treeID")


class Hash4(RootModel[StrictStr]):
    root: StrictStr = Field(..., description="SHA256 hash value expressed in hexadecimal format")


class ConsistencyProof(BaseModel):
    root_hash: StrictStr = Field(
        ...,
        alias="rootHash",
        description=(
            "The hash value stored at the root of the merkle tree at the time the proof was"
            " generated"
        ),
    )
    hashes: List[Hash4]


class InclusionProof(BaseModel):
    log_index: StrictInt = Field(
        ...,
        alias="logIndex",
        description="The index of the entry in the transparency log",
    )
    root_hash: StrictStr = Field(
        ...,
        alias="rootHash",
        description=(
            "The hash value stored at the root of the merkle tree at the time the proof was"
            " generated"
        ),
    )
    tree_size: StrictInt = Field(
        ...,
        alias="treeSize",
        description="The size of the merkle tree at the time the inclusion proof was generated",
    )
    hashes: List[Hash4] = Field(
        ...,
        description=(
            "A list of hashes required to compute the inclusion proof, sorted in order from leaf to"
            " root"
        ),
    )
    checkpoint: StrictStr = Field(
        ...,
        description="The checkpoint (signed tree head) that the inclusion proof is based on",
    )


class Error(BaseModel):
    code: Optional[StrictInt] = None
    message: Optional[StrictStr] = None


class RekordSchema(RootModel[RekordV001Schema]):
    root: RekordV001Schema = Field(
        ...,
        description="Schema for Rekord objects",
        title="Rekor Schema",
    )


class HashedrekordSchema(RootModel[HashedrekordV001Schema]):
    root: HashedrekordV001Schema = Field(
        ...,
        description="Schema for Rekord objects",
        title="Rekor Schema",
    )


class RpmSchema(RootModel[RpmV001Schema]):
    root: RpmV001Schema = Field(..., description="Schema for RPM objects", title="RPM Schema")


class TufSchema(RootModel[TufV001Schema]):
    root: TufV001Schema = Field(
        ...,
        description="Schema for TUF metadata objects",
        title="TUF Schema",
    )


class AlpineSchema(RootModel[AlpineV001Schema]):
    root: AlpineV001Schema = Field(
        ...,
        description="Schema for Alpine package objects",
        title="Alpine Package Schema",
    )


class HelmSchema(RootModel[HelmV001Schema]):
    root: HelmV001Schema = Field(..., description="Schema for Helm objects", title="Helm Schema")


class IntotoSchema(RootModel[Union[IntotoV001Schema, IntotoV002Schema]]):
    root: Union[IntotoV001Schema, IntotoV002Schema] = Field(
        ...,
        description="Intoto for Rekord objects",
        title="Intoto Schema",
    )


class CoseSchema(RootModel[CoseV001Schema]):
    root: CoseV001Schema = Field(..., description="COSE for Rekord objects", title="COSE Schema")


class JarSchema(RootModel[JarV001Schema]):
    root: JarV001Schema = Field(..., description="Schema for JAR objects", title="JAR Schema")


class Rfc3161Schema(RootModel[Rfc3161V001Schema]):
    root: Rfc3161V001Schema = Field(
        ...,
        description="Schema for RFC 3161 timestamp objects",
        title="Timestamp Schema",
    )


class DsseSchema(RootModel[DsseV001Schema]):
    root: DsseV001Schema = Field(
        ...,
        description="log entry schema for dsse envelopes",
        title="DSSE Schema",
    )


class Verification(BaseModel):
    inclusion_proof: Optional[InclusionProof] = Field(None, alias="inclusionProof")
    signed_entry_timestamp: Optional[str] = Field(
        None,
        alias="signedEntryTimestamp",
        description="Signature over the logID, logIndex, body and integratedTime.",
        pattern="^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
    )


class LogEntry1(BaseModel):
    log_id: StrictStr = Field(
        ...,
        alias="logID",
        description=(
            "This is the SHA256 hash of the DER-encoded public key for the log at the time the"
            " entry was included in the log"
        ),
    )
    log_index: StrictInt = Field(..., alias="logIndex")
    body: Dict[str, Any]
    integrated_time: StrictInt = Field(
        ...,
        alias="integratedTime",
        description="The time the entry was added to the log as a Unix timestamp in seconds",
    )
    attestation: Optional[Attestation] = None
    verification: Optional[Verification] = None


class LogEntry(RootModel[Optional[Dict[str, LogEntry1]]]):
    root: Optional[Dict[str, LogEntry1]] = None


class LogInfo(BaseModel):
    root_hash: StrictStr = Field(
        ...,
        alias="rootHash",
        description="The current hash value stored at the root of the merkle tree",
    )
    tree_size: StrictInt = Field(
        ...,
        alias="treeSize",
        description="The current number of nodes in the merkle tree",
    )
    signed_tree_head: StrictStr = Field(
        ...,
        alias="signedTreeHead",
        description="The current signed tree head",
    )
    tree_id: StrictStr = Field(..., alias="treeID", description="The current treeID")
    inactive_shards: Optional[List[InactiveShardLogInfo]] = Field(None, alias="inactiveShards")


class Rekord(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: RekordSchema


class Hashedrekord(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: HashedrekordSchema


class Rpm(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: RpmSchema


class Tuf(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: TufSchema


class Alpine(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: AlpineSchema


class Helm(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: HelmSchema


class Intoto(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: IntotoSchema


class Cose(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: CoseSchema


class Jar(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: JarSchema


class Rfc3161(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: Rfc3161Schema


class Dsse(ProposedEntry):
    api_version: StrictStr = Field(..., alias="apiVersion")
    spec: DsseSchema
